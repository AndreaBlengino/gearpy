from gearpy.units import (
    AngularPosition,
    AngularSpeed,
    AngularAcceleration,
    Angle,
    Force,
    InertiaMoment,
    Length,
    Stress,
    Time,
    Torque,
    UnitBase
)
from math import sqrt, atan
from .mechanical_object_base import RotatingObject, lewis_factor_function, Role
from .mating_roles import MatingMaster, MatingSlave
from .spur_gear import SpurGear
from typing import Callable, Optional


class HelicalGear(SpurGear):
    r""":py:class:`HelicalGear <gearpy.mechanical_objects.helical_gear.HelicalGear>` object.

    Attributes
    ----------
    :py:attr:`name` : :py:class:`str`
        Name of the helical gear.
    :py:attr:`n_teeth` : :py:class:`int`
        Number of gear teeth.
    :py:attr:`inertia_moment` : :py:class:`InertiaMoment <gearpy.units.units.InertiaMoment>`
        Moment of inertia of the gear.
    :py:attr:`helix_angle` : :py:class:`Angle <gearpy.units.units.Angle>`
        Helix angle of the helical gear.
    :py:attr:`module` : :py:class:`Length <gearpy.units.units.Length>`
        Unit of the gear teeth size.
    :py:attr:`reference_diameter` : :py:class:`Length <gearpy.units.units.Length>`
        Reference diameter of the gear.
    :py:attr:`face_width` : :py:class:`Length <gearpy.units.units.Length>`
        Face width of the gear.
    :py:attr:`elastic_modulus` : :py:class:`Stress <gearpy.units.units.Stress>`
        Elastic modulus of the material of the gear.
    :py:attr:`lewis_factor` : :py:class:`float`
        Factor used to compute stresses on the gear tooth.
    :py:attr:`driven_by` : :py:class:`RotatingObject <gearpy.mechanical_objects.mechanical_object_base.RotatingObject>`
        Rotating object that drives the gear, for example a
        :py:class:`DCMotor <gearpy.mechanical_objects.dc_motor.DCMotor>`, a
        :py:class:`Flywheel <gearpy.mechanical_objects.flywheel.Flywheel>` or
        another gear
        (:py:class:`SpurGear <gearpy.mechanical_objects.spur_gear.SpurGear>`,
        :py:class:`HelicalGear <gearpy.mechanical_objects.helical_gear.HelicalGear>`,
        :py:class:`WormGear <gearpy.mechanical_objects.worm_gear.WormGear>`,
        :py:class:`WormWheel <gearpy.mechanical_objects.worm_wheel.WormWheel>`).
    :py:attr:`drives` : :py:class:`RotatingObject <gearpy.mechanical_objects.mechanical_object_base.RotatingObject>`
        Rotating object driven by the gear, it can be a
        :py:class:`Flywheel <gearpy.mechanical_objects.flywheel.Flywheel>` or
        another gear
        (:py:class:`SpurGear <gearpy.mechanical_objects.spur_gear.SpurGear>`,
        :py:class:`HelicalGear <gearpy.mechanical_objects.helical_gear.HelicalGear>`,
        :py:class:`WormGear <gearpy.mechanical_objects.worm_gear.WormGear>`,
        :py:class:`WormWheel <gearpy.mechanical_objects.worm_wheel.WormWheel>`).
    :py:attr:`master_gear_ratio` : :py:class:`float`
        Gear ratio of the mating between the gear and its driving gear.
    :py:attr:`master_gear_efficiency` : :py:class:`float` or :py:class:`int`
        Efficiency of the gear mating between the gear and its driving gear.
    :py:attr:`mating_role`: :py:class:`Role <gearpy.mechanical_objects.mechanical_object_base.Role>`
        The role of the gear in the gear mating.
    :py:attr:`angular_position` : :py:class:`AngularPosition <gearpy.units.units.AngularPosition>`
        Angular position of the gear.
    :py:attr:`angular_speed` : :py:class:`AngularSpeed <gearpy.units.units.AngularSpeed>`
        Angular speed of the gear.
    :py:attr:`angular_acceleration` : :py:class:`AngularAcceleration <gearpy.units.units.AngularAcceleration>`
        Angular acceleration of the gear.
    :py:attr:`torque` : :py:class:`Torque <gearpy.units.units.Torque>`
        Net torque applied on the gear.
    :py:attr:`driving_torque` : :py:class:`Torque <gearpy.units.units.Torque>`
        Driving torque applied on the gear by its driving gear.
    :py:attr:`load_torque` : :py:class:`Torque <gearpy.units.units.Torque>`
        Load torque applied on the gear by its driven gear or an external load.
    :py:attr:`tangential_force` : :py:class:`Force <gearpy.units.units.Force>`
        Tangential force applied on the gear teeth by the mating gear.
    :py:attr:`tangential_force_is_computable` : :py:class:`bool`
        Whether is possible to compute the :py:attr:`tangential_force` on the
        gear teeth.
    :py:attr:`bending_stress` : :py:class:`Stress <gearpy.units.units.Stress>`
        Bending stress applied on the gear teeth by the mating gear.
    :py:attr:`bending_stress_is_computable` : :py:class:`bool`
        Whether is possible to compute the :py:attr:`bending_stress` on the
        gear teeth.
    :py:attr:`contact_stress` : :py:class:`Stress <gearpy.units.units.Stress>`
        The stress generated by the contact with mating gear teeth.
    :py:attr:`contact_stress_is_computable` : :py:class:`bool`
        Whether is possible to compute the :py:attr:`contact_stress` on the
        gear teeth.
    :py:attr:`time_variables` : :py:class:`dict`
        Time variables of the gear.

    Methods
    -------
    :py:meth:`compute_tangential_force`
        It computes the :py:attr:`tangential_force` applied on the gear teeth
        by the mating gear.
    :py:meth:`compute_bending_stress`
        It computes the :py:attr:`bending_stress` applied on the gear teeth by
        the mating gear.
    :py:meth:`compute_contact_stress`
        It computes the :py:attr:`contact_stress` generated by the contact with
        mating gear teeth.
    :py:meth:`external_torque`
        Custom function to compute the external torque applied on the gear.
    :py:meth:`update_time_variables`
        It updates :py:attr:`time_variables` dictionary by appending the last
        value of each time variable to corresponding list.
    """

    def __init__(
        self,
        name: str,
        n_teeth: int,
        inertia_moment: InertiaMoment,
        helix_angle: Angle,
        module: Optional[Length] = None,
        face_width: Optional[Length] = None,
        elastic_modulus: Optional[Stress] = None
    ):
        super().__init__(
            name=name,
            n_teeth=n_teeth,
            module=module,
            face_width=face_width,
            inertia_moment=inertia_moment,
            elastic_modulus=elastic_modulus
        )

        if not isinstance(helix_angle, Angle):
            raise TypeError(
                f"Parameter 'helix_angle' must be an instance of "
                f"{Angle.__name__!r}."
            )

        if helix_angle >= Angle(90, 'deg'):
            raise ValueError(
                "Parameter 'helix_angle' cannot be greater than or equal to "
                "90 degrees."
            )

        self.__helix_angle = helix_angle

        if self.tangential_force_is_computable:
            self.time_variables['tangential force'] = []

            if self.bending_stress_is_computable:
                self.time_variables['bending stress'] = []
                PRESSURE_ANGLE = Angle(20, 'deg')
                self.__TRANSVERSE_PRESSURE_ANGLE = Angle(
                    value=atan(PRESSURE_ANGLE.tan()/helix_angle.cos()),
                    unit='rad'
                )
                BASE_HELIX_ANGLE = Angle(
                    value=atan(
                        self.__TRANSVERSE_PRESSURE_ANGLE.cos() *
                        self.__helix_angle.tan()
                    ),
                    unit='rad'
                )
                virtual_n_teeth = n_teeth/(BASE_HELIX_ANGLE.cos())**2 / \
                    self.__helix_angle.cos()

                self.__lewis_factor = lewis_factor_function(
                    virtual_n_teeth
                ).take(0)

                if self.contact_stress_is_computable:
                    self.time_variables['contact stress'] = []

    @property
    def name(self) -> str:
        """Name of the helical gear. It must be a non-empty :py:class:`str`. \n
        It must be a unique name, not shared by other elements in the
        powertrain elements. \n
        Once set at the helical gear instantiation, it cannot be changed
        afterward.

        Returns
        -------
        :py:class:`str`
            Name of the helical gear.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If :py:attr:`name` is not a :py:class:`str`.
           ``ValueError``
               If :py:attr:`name` is an empty :py:class:`str`.
        """
        return super().name

    @property
    def n_teeth(self) -> int:
        """Number of gear teeth. It must be a positive :py:class:`int`. \n
        Once set at the helical gear instantiation, it cannot be changed
        afterward.

        Returns
        -------
        :py:class:`int`
            Number of gear teeth.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If :py:attr:`n_teeth` is not an :py:class:`int`.
           ``ValueError``
               If :py:attr:`n_teeth` is less than the minimum number of teeth,
               based on Lewis Factor table.
        """
        return super().n_teeth

    @property
    def inertia_moment(self) -> InertiaMoment:
        """Moment of inertia of the gear. It must be an instance of
        :py:class:`InertiaMoment <gearpy.units.units.InertiaMoment>`. \n
        Once set at the helical gear instantiation, it cannot be changed
        afterward.

        Returns
        -------
        :py:class:`InertiaMoment <gearpy.units.units.InertiaMoment>`
            Moment of inertia of the gear.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If :py:attr:`inertia_moment` is not an instance of
               :py:class:`InertiaMoment <gearpy.units.units.InertiaMoment>`.
        """
        return super().inertia_moment

    @property
    def helix_angle(self) -> Angle:
        """Helix angle of the helical gear. It must be an instance of
        :py:class:`Angle <gearpy.units.units.Angle>` lower than 90 degrees. \n
        Once set at the helical gear instantiation, it cannot be changed
        afterward.

        Returns
        -------
        :py:class:`Angle <gearpy.units.units.Angle>`
            The helix angle of the helical gear.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If :py:attr:`helix_angle` is not an instance of
               :py:class:`Angle <gearpy.units.units.Angle>`.
           ``ValueError``
               If :py:attr:`helix_angle` is greater than or equal to 90
               degrees.
        """
        return self.__helix_angle

    @property
    def module(self) -> Optional[Length]:
        """Unit of the gear teeth size. It must be an instance of
        :py:class:`Length <gearpy.units.units.Length>`. \n
        Once set at the helical gear instantiation, it cannot be changed
        afterward.

        Returns
        -------
        :py:class:`Length <gearpy.units.units.Length>`
            Unit of the gear teeth size.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If :py:attr:`module` is not an instance of
               :py:class:`Length <gearpy.units.units.Length>`.
        """
        return super().module

    @property
    def reference_diameter(self) -> Optional[Length]:
        """Reference diameter of the gear. It must be an instance of
        :py:class:`Length <gearpy.units.units.Length>`. \n
        It is computed as the product of :py:attr:`n_teeth` times
        :py:attr:`module` at the helical gear instantiation and it cannot be
        changed afterward.

        Returns
        -------
        :py:class:`Length <gearpy.units.units.Length>`
            Reference diameter of the gear.
        """
        return super().reference_diameter

    @property
    def face_width(self) -> Optional[Length]:
        """Face width of the gear. It must be an instance of
        :py:class:`Length <gearpy.units.units.Length>`.

        Returns
        -------
        :py:class:`Length <gearpy.units.units.Length>`
            Face width of the gear.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If :py:attr:`face_width` is not an instance of
               :py:class:`Length <gearpy.units.units.Length>`.
        """
        return super().face_width

    @property
    def elastic_modulus(self) -> Optional[Stress]:
        """Elastic modulus of the material of the gear. It must be an instance
        of :py:class:`Stress <gearpy.units.units.Stress>`. It must be positive.

        Returns
        -------
        :py:class:`Stress <gearpy.units.units.Stress>`
            Elastic modulus of the material of the gear.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If :py:attr:`elastic_modulus` is not an instance of
               :py:class:`Stress <gearpy.units.units.Stress>`.
           ``ValueError``
               If :py:attr:`elastic_modulus` value is negative or null.
        """
        return super().elastic_modulus

    @property
    def lewis_factor(self) -> Optional[float]:
        """Factor used to compute stresses on the gear tooth. \n
        It is a tabular value that in general depends on the number of gear
        teeth, the pressure angle and the helix angle. In this case, the
        considered pressure angle is always 20 degrees, so the Lewis factor
        depends only on the number of gear teeth :py:attr:`n_teeth` and the
        :py:attr:`helix_angle`.

        Returns
        -------
        :py:class:`float`
            Factor used to compute stresses on the gear tooth.
        """\
        r"""
        .. admonition:: Notes
           :class: tip

           The Lewis factor is a tabular value that depends on the helical
           gear virtual number of teeth, which can be computed as:

           .. math::
               z_v = \frac{z}{\cos^2 \beta_b \, \cos \beta}

           where:

           - :math:`z` is the gear number of teeth :py:attr:`n_teeth`,
           - :math:`\beta` is the gear :py:attr:`helix_angle`,
           - :math:`\beta_b` is the gear base helix angle.

           The gear base helix angle :math:`\beta_b` can be computed as:

           .. math::
               \beta_b = \tan^{-1} \left( \cos \alpha_t \, \cos \beta \right)

           where the :math:`\alpha_t` is the gear transverse pressure angle,
           which can be computed as:

           .. math::
               \alpha_t = \tan^{-1} \frac{\tan \alpha}{\cos \beta}

           where :math:`\alpha` is the pressure angle of the gear, always
           equal to 20 degrees.
        """
        return self.__lewis_factor

    @property
    def driven_by(self) -> RotatingObject:
        """Rotating object that drives the gear, for example a
        :py:class:`DCMotor <gearpy.mechanical_objects.dc_motor.DCMotor>`, a
        :py:class:`Flywheel <gearpy.mechanical_objects.flywheel.Flywheel>` or
        another gear
        (:py:class:`SpurGear <gearpy.mechanical_objects.spur_gear.SpurGear>`,
        :py:class:`HelicalGear <gearpy.mechanical_objects.helical_gear.HelicalGear>`,
        :py:class:`WormGear <gearpy.mechanical_objects.worm_gear.WormGear>`,
        :py:class:`WormWheel <gearpy.mechanical_objects.worm_wheel.WormWheel>`).
        It must be a
        :py:class:`RotatingObject <gearpy.mechanical_objects.mechanical_object_base.RotatingObject>`. \n
        To set this property use
        :py:func:`add_gear_mating <gearpy.utils.relations.add_gear_mating>` or
        :py:func:`add_fixed_joint <gearpy.utils.relations.add_fixed_joint>`.

        Returns
        -------
        :py:class:`RotatingObject <gearpy.mechanical_objects.mechanical_object_base.RotatingObject>`
            Master rotating object that drives the gear.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If :py:attr:`driven_by` is not an instance of
               :py:class:`RotatingObject <gearpy.mechanical_objects.mechanical_object_base.RotatingObject>`.
        """
        return super().driven_by

    @driven_by.setter
    def driven_by(self, driven_by: RotatingObject):
        super(HelicalGear, type(self)).driven_by.fset(self, driven_by)

    @property
    def drives(self) -> RotatingObject:
        """Rotating object driven by the gear, it can be a
        :py:class:`Flywheel <gearpy.mechanical_objects.flywheel.Flywheel>` or
        another gear
        (:py:class:`SpurGear <gearpy.mechanical_objects.spur_gear.SpurGear>`,
        :py:class:`HelicalGear <gearpy.mechanical_objects.helical_gear.HelicalGear>`,
        :py:class:`WormGear <gearpy.mechanical_objects.worm_gear.WormGear>`,
        :py:class:`WormWheel <gearpy.mechanical_objects.worm_wheel.WormWheel>`).
        It must be a
        :py:class:`RotatingObject <gearpy.mechanical_objects.mechanical_object_base.RotatingObject>`. \n
        To set this property use
        :py:func:`add_gear_mating <gearpy.utils.relations.add_gear_mating>` or
        :py:func:`add_fixed_joint <gearpy.utils.relations.add_fixed_joint>`.

        Returns
        -------
        :py:class:`RotatingObject <gearpy.mechanical_objects.mechanical_object_base.RotatingObject>`
            Rotating object driven by the gear.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If :py:attr:`drives` is not an instance of
               :py:class:`RotatingObject <gearpy.mechanical_objects.mechanical_object_base.RotatingObject>`.
        """
        return super().drives

    @drives.setter
    def drives(self, drives: RotatingObject):
        super(HelicalGear, type(self)).drives.fset(self, drives)

    @property
    def master_gear_ratio(self) -> float:
        """Gear ratio of the mating between the gear and its driving gear. It
        must be a positive a :py:class:`float`. \n
        If the gear is fixed to another driving
        :py:class:`RotatingObject <gearpy.mechanical_objects.mechanical_object_base.RotatingObject>`,
        then the ratio is ``1``, otherwise it is defined as the ratio between
        the gear number of teeth :py:attr:`n_teeth` and the same parameter of
        the master (driving) gear. \n
        To set this property use
        :py:func:`add_gear_mating <gearpy.utils.relations.add_gear_mating>` or
        :py:func:`add_fixed_joint <gearpy.utils.relations.add_fixed_joint>`.

        Returns
        -------
        :py:class:`float`
            Gear ratio of the mating between the gear and its driving gear.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If :py:attr:`master_gear_ratio` is not a :py:class:`float`.
           ``ValueError``
               If :py:attr:`master_gear_ratio` is negative or null.
        """
        return super().master_gear_ratio

    @master_gear_ratio.setter
    def master_gear_ratio(self, master_gear_ratio: float):
        super(
            HelicalGear,
            type(self)
        ).master_gear_ratio.fset(self, master_gear_ratio)

    @property
    def master_gear_efficiency(self) -> float | int:
        """Efficiency of the gear mating between the gear and its driving gear.
        It must be a :py:class:`float` or an :py:class:`int` within ``0`` and
        ``1``. \n
        To set this property use
        :py:func:`add_gear_mating <gearpy.utils.relations.add_gear_mating>` or
        :py:func:`add_fixed_joint <gearpy.utils.relations.add_fixed_joint>`.

        Returns
        -------
        :py:class:`float` or :py:class:`int`
            Efficiency of the gear mating between the gear and its driving
            gear.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If :py:attr:`master_gear_efficiency` is not a :py:class:`float`
               or an :py:class:`int`.
           ``ValueError``
               If :py:attr:`master_gear_efficiency` is not within ``0`` and
               ``1``.
        """
        return super().master_gear_efficiency

    @master_gear_efficiency.setter
    def master_gear_efficiency(self, master_gear_efficiency: float | int):
        super(
            HelicalGear,
            type(self)
        ).master_gear_efficiency.fset(self, master_gear_efficiency)

    @property
    def mating_role(self) -> Role:
        """Role of the gear in the gear mating. \n
        If the gear drives the mate one, then it is the "master" gear and its
        role is
        :py:class:`MatingMaster <gearpy.mechanical_objects.mating_roles.MatingMaster>`,
        otherwise it is the "slave" one and its role is
        :py:class:`MatingSlave <gearpy.mechanical_objects.mating_roles.MatingSlave>`. \n
        To set this parameter use
        :py:func:`add_gear_mating <gearpy.utils.relations.add_gear_mating>`.

        Returns
        -------
        :py:class:`Role <gearpy.mechanical_objects.mechanical_object_base.Role>`
            The role of the gear in the gear mating.

        .. admonition:: Raises
           :class: warning

           ``ValueError``
               If :py:attr:`mating_role` is not a subclass of
               :py:class:`Role <gearpy.mechanical_objects.mechanical_object_base.Role>`.
        """
        return super().mating_role

    @mating_role.setter
    def mating_role(self, mating_role: Role):
        super(HelicalGear, type(self)).mating_role.fset(self, mating_role)

    @property
    def angular_position(self) -> AngularPosition:
        """Angular position of the gear. It must be an instance of
        :py:class:`AngularPosition <gearpy.units.units.AngularPosition>`.

        Returns
        -------
        :py:class:`AngularPosition <gearpy.units.units.AngularPosition>`
            Angular position of the gear.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If ``angular_position`` is not an instance of
               :py:class:`AngularPosition <gearpy.units.units.AngularPosition>`.
        """
        return super().angular_position

    @angular_position.setter
    def angular_position(self, angular_position: AngularPosition):
        super(
            HelicalGear,
            type(self)
        ).angular_position.fset(self, angular_position)

    @property
    def angular_speed(self) -> AngularSpeed:
        """Angular speed of the gear. It must be an instance of
        :py:class:`AngularSpeed <gearpy.units.units.AngularSpeed>`.

        Returns
        -------
        :py:class:`AngularSpeed <gearpy.units.units.AngularSpeed>`
            Angular speed of the gear.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If :py:attr:`angular_speed` is not an instance of
               :py:class:`AngularSpeed <gearpy.units.units.AngularSpeed>`.
        """
        return super().angular_speed

    @angular_speed.setter
    def angular_speed(self, angular_speed: AngularSpeed):
        super(HelicalGear, type(self)).angular_speed.fset(self, angular_speed)

    @property
    def angular_acceleration(self) -> AngularAcceleration:
        """Angular acceleration of the gear. It must be an instance of
        :py:class:`AngularAcceleration <gearpy.units.units.AngularAcceleration>`.

        Returns
        -------
        :py:class:`AngularAcceleration <gearpy.units.units.AngularAcceleration>`
            Angular acceleration of the gear.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If :py:attr:`angular_acceleration` is not an instance of
               :py:class:`AngularAcceleration <gearpy.units.units.AngularAcceleration>`.
        """
        return super().angular_acceleration

    @angular_acceleration.setter
    def angular_acceleration(self, angular_acceleration: AngularAcceleration):
        super(
            HelicalGear,
            type(self)
        ).angular_acceleration.fset(self, angular_acceleration)

    @property
    def torque(self) -> Torque:
        """Net torque applied on the gear. It must be an instance of
        :py:class:`Torque <gearpy.units.units.Torque>`. \n
        It is computed as the difference between :py:attr:`driving_torque` and
        :py:attr:`load_torque`.

        Returns
        -------
        :py:class:`Torque <gearpy.units.units.Torque>`
            Net torque applied on the gear.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If :py:attr:`torque` is not an instance of
               :py:class:`Torque <gearpy.units.units.Torque>`.
        """
        return super().torque

    @torque.setter
    def torque(self, torque: Torque):
        super(HelicalGear, type(self)).torque.fset(self, torque)

    @property
    def driving_torque(self) -> Torque:
        """Driving torque applied on the gear by its driving gear. It must be
        an instance of :py:class:`Torque <gearpy.units.units.Torque>`.

        Returns
        -------
        :py:class:`Torque <gearpy.units.units.Torque>`
            Driving torque applied on the gear by its driving gear.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If :py:attr:`driving_torque` is not an instance of
               :py:class:`Torque <gearpy.units.units.Torque>`.
        """
        return super().driving_torque

    @driving_torque.setter
    def driving_torque(self, driving_torque: Torque):
        super(
            HelicalGear,
            type(self)
        ).driving_torque.fset(self, driving_torque)

    @property
    def load_torque(self) -> Torque:
        """Load torque applied on the gear by its driven gear or an external
        load. It must be an instance of
        :py:class:`Torque <gearpy.units.units.Torque>`.

        Returns
        -------
        :py:class:`Torque <gearpy.units.units.Torque>`
            Load torque applied on the gear by its driven gear or an external
            load.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If :py:attr:`load_torque` is not an instance of
               :py:class:`Torque <gearpy.units.units.Torque>`.
        """
        return super().load_torque

    @load_torque.setter
    def load_torque(self, load_torque: Torque):
        super(HelicalGear, type(self)).load_torque.fset(self, load_torque)

    @property
    def tangential_force(self) -> Force:
        """Tangential force applied on the gear teeth by the mating gear. It
        must be an instance of :py:class:`Force <gearpy.units.units.Force>`.

        Returns
        -------
        :py:class:`Force <gearpy.units.units.Force>`
            Tangential force applied on the gear teeth by the mating gear.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If :py:attr:`tangential_force` is not an instance of
               :py:class:`Force <gearpy.units.units.Force>`.

        .. admonition:: See Also
           :class: seealso

           :py:meth:`compute_tangential_force`
        """
        return super().tangential_force

    @tangential_force.setter
    def tangential_force(self, tangential_force: Force):
        super(
            HelicalGear,
            type(self)
        ).tangential_force.fset(self, tangential_force)

    def compute_tangential_force(self) -> None:
        """It computes the :py:attr:`tangential_force` applied on the gear
        teeth by the mating gear. \n
        Considering a gear mating:

        - if the gear is the master one, then it takes into account the
          :py:attr:`load_torque` for the computation,
        - if the gear is the slave one, then it take into account the
          :py:attr:`driving_torque` for the computation.

        The tangential force is computed dividing the just described reference
        torque by the reference radius (half of the
        :py:attr:`reference_diameter`).

        .. admonition:: Raises
           :class: warning

           ``ValueError``
               If a gear mating between two gears has not been set.
        """
        if self.mating_role == MatingMaster:
            self.tangential_force = \
                abs(self.load_torque)/(self.reference_diameter/2)
        elif self.mating_role == MatingSlave:
            self.tangential_force = \
                abs(self.driving_torque)/(self.reference_diameter/2)
        else:
            raise ValueError(
                "Gear mating not defined. Use 'gearpy.utils.add_gear_mating' "
                "to set up a mating between two gears."
            )

    @property
    def tangential_force_is_computable(self) -> bool:
        """Whether is possible to compute the :py:attr:`tangential_force` on
        the gear teeth. \n
        The tangential force computation depends on the value of
        :py:attr:`module`, so if this optional parameter has been set at
        helical gear instantiation, then it is possible to compute the
        tangential force and this property is ``True``, otherwise is ``False``.

        Returns
        -------
        :py:class:`bool`
            Whether is possible to compute the tangential force on the gear
            teeth.

        .. admonition:: See Also
           :class: seealso

           :py:meth:`compute_tangential_force`
        """
        return super().tangential_force_is_computable

    @property
    def bending_stress(self) -> Stress:
        """Bending stress applied on the gear teeth by the mating gear. It
        must be an instance of :py:class:`Stress <gearpy.units.units.Stress>`.

        Returns
        -------
        :py:class:`Stress <gearpy.units.units.Stress>`
            Bending stress applied on the gear teeth by the mating gear.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If :py:attr:`bending_stress` is not an instance of
               :py:class:`Stress <gearpy.units.units.Stress>`.

        .. admonition:: See Also
           :class: seealso

           :py:meth:`compute_bending_stress`
        """
        return super().bending_stress

    @bending_stress.setter
    def bending_stress(self, bending_stress: Stress):
        super(
            HelicalGear,
            type(self)
        ).bending_stress.fset(self, bending_stress)

    def compute_bending_stress(self) -> None:
        r"""It computes the :py:attr:`bending_stress` applied on the gear teeth
        by the mating gear.

        .. admonition:: Notes
           :class: tip

           The bending stress computation is based on the following
           assumptions:

           - the tooth is stressed by the overall force acting on the tip of
             the tooth itself,
           - the most unfavorable situation is considered in the calculation,
             as if there is only one pair of teeth in contact within the
             contact segment,
           - the component of the overall force that determines the bending on
             the tooth is the only one considered and, for simplicity, is taken
             as having a value equal to the tangential force on the reference
             diameter,
           - the radial component of the overall force that causes a
             compressive stress on the tooth is neglected.

           The bending stress is computed with the following formula:

           .. math::
               \sigma_b = \frac{F_t}{m \, b \, Y_{LW}}

           where:

           - :math:`F_t` is the :py:attr:`tangential_force` applied on the
             tooth,
           - :math:`m` is the gear :py:attr:`module`,
           - :math:`b` is the gear tooth :py:attr:`face_width`,
           - :math:`Y_{LW}` is the gear :py:attr:`lewis_factor`.
        """
        self.bending_stress = self.tangential_force / \
            (self.module*self.face_width)/self.lewis_factor

    @property
    def bending_stress_is_computable(self) -> bool:
        """Whether is possible to compute the :py:attr:`bending_stress` on the
        gear teeth. \n
        The bending stress computation depends on the value of
        :py:attr:`module` and :py:attr:`face_width`, so if these optional
        parameters have been set at helical gear instantiation, then it is
        possible to compute the bending stress and this property is ``True``,
        otherwise is ``False``.

        Returns
        -------
        :py:class:`bool`
            Whether is possible to compute the bending stress on the gear
            teeth.

        .. admonition:: See Also
           :class: seealso

           :py:meth:`compute_bending_stress`
        """
        return super().bending_stress_is_computable

    @property
    def contact_stress(self) -> Stress:
        """Stress generated by the contact with mating gear teeth. It must be
        an instance of :py:class:`Stress <gearpy.units.units.Stress>`.

        Returns
        -------
        :py:class:`Stress <gearpy.units.units.Stress>`
            The stress generated by the contact with mating gear teeth.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If :py:attr:`contact_stress` is not an instance of
               :py:class:`Stress <gearpy.units.units.Stress>`.

        .. admonition:: See Also
           :class: seealso

           :py:meth:`compute_contact_stress`
        """
        return super().contact_stress

    @contact_stress.setter
    def contact_stress(self, contact_stress: Stress):
        super(
            HelicalGear,
            type(self)
        ).contact_stress.fset(self, contact_stress)

    def compute_contact_stress(self) -> None:
        r"""It computes the :py:attr:`contact_stress` generated by the contact
        with mating gear teeth.

        .. admonition:: Raises
           :class: warning

           ``ValueError``
               - If a gear mating between two gears has not been set,
               - if :py:attr:`mating_role` is
                 :py:class:`MatingMaster <gearpy.mechanical_objects.mating_roles.MatingMaster>`
                 and its slave gear misses :py:attr:`module` parameter,
               - if :py:attr:`mating_role` is
                 :py:class:`MatingMaster <gearpy.mechanical_objects.mating_roles.MatingMaster>`
                 and its slave gear misses :py:attr:`elastic_modulus`
                 parameter,
               - if :py:attr:`mating_role` is
                 :py:class:`MatingSlave <gearpy.mechanical_objects.mating_roles.MatingSlave>`
                 and its master gear misses :py:attr:`module` parameter,
               - if :py:attr:`mating_role` is
                 :py:class:`MatingSlave <gearpy.mechanical_objects.mating_roles.MatingSlave>`
                 and its master gear misses :py:attr:`elastic_modulus`
                 parameter.

        .. admonition:: Notes
           :class: tip

           The contact stress computation is based on the following
           assumptions:

           - perfect elasticity of the materials the two mating gear,
           - absence of friction forces in the contact point,
           - small size of the contact surface compared to the size of the
             bodies between which contact occurs.

           The contact stress is computed with the following formula:

           .. math::
               \sigma_c = 0.262922 \, \sqrt{\frac{4 \, F_t \, \cos \beta}
               {b \, \cos \alpha_t \, \sin \alpha_t} \left( \frac{1}{D_1} +
               \frac{1}{D_2} \right) \, \frac{E_1 \, E_2}{E_1 + E_2}}

           where:

           - :math:`F_t` is the :py:attr:`tangential_force` applied on the
             tooth,
           - :math:`\beta` is the gear :py:attr:`helix_angle`,
           - :math:`b` is the gear :py:attr:`face_width`,
           - :math:`\alpha_t` is the transverse pressure angle of the gear,
           - :math:`D_1` is the gear :py:attr:`reference_diameter`,
           - :math:`D_2` is the mating gear :py:attr:`reference_diameter`,
           - :math:`E_1` is the gear :py:attr:`elastic_modulus`,
           - :math:`E_2` is the mating gear :py:attr:`elastic_modulus`.

           The transverse pressure angle of the gear can be computed with the
           formula:

           .. math::
               \alpha_t = \tan^{-1} \frac{\tan \alpha}{\cos \beta}

           where :math:`\alpha` is the pressure angle of the gear, always
           equal to 20 degrees.
        """
        if self.mating_role == MatingMaster:
            if self.drives.module is not None:
                mate_reference_diameter = self.drives.reference_diameter
            else:
                raise ValueError(
                    f"Impossible to compute contact stress for "
                    f"{self.__class__.__name__} {self.name!r} because its "
                    f"mating {self.__class__.__name__} {self.drives.name!r} "
                    f"misses 'module' parameter."
                )
            if self.drives.elastic_modulus is not None:
                mate_elastic_modulus = self.drives.elastic_modulus
            else:
                raise ValueError(
                    f"Impossible to compute contact stress for "
                    f"{self.__class__.__name__} {self.name!r} because its "
                    f"mating {self.__class__.__name__} {self.drives.name!r} "
                    f"misses 'elastic_modulus' parameter."
                )
        elif self.mating_role == MatingSlave:
            if self.driven_by.module is not None:
                mate_reference_diameter = self.driven_by.reference_diameter
            else:
                raise ValueError(
                    f"Impossible to compute contact stress for "
                    f"{self.__class__.__name__} {self.name!r} because its "
                    f"mating {self.__class__.__name__} {self.driven_by.name!r}"
                    f" misses 'module' parameter."
                )
            if self.driven_by.elastic_modulus is not None:
                mate_elastic_modulus = self.driven_by.elastic_modulus
            else:
                raise ValueError(
                    f"Impossible to compute contact stress for "
                    f"{self.__class__.__name__} {self.name!r} because its "
                    f"mating {self.__class__.__name__} {self.driven_by.name!r}"
                    f" misses 'elastic_modulus' parameter."
                )
        else:
            raise ValueError(
                "Gear mating not defined. Use 'gearpy.utils.add_gear_mating' "
                "to set up a mating between two gears."
            )

        equivalent_elastic_modulus = 2*self.elastic_modulus * \
            (mate_elastic_modulus /
                (self.elastic_modulus + mate_elastic_modulus))
        inverse_curvature_sum = \
            self.__TRANSVERSE_PRESSURE_ANGLE.sin()/2 * \
            self.reference_diameter*(
                mate_reference_diameter /
                (self.reference_diameter + mate_reference_diameter)
            )
        contact_pressure = \
            self.tangential_force/self.__TRANSVERSE_PRESSURE_ANGLE.cos() / \
            (self.face_width/self.__helix_angle.cos()*inverse_curvature_sum)

        self.contact_stress = Stress(
            value=0.262922*sqrt(
                equivalent_elastic_modulus.to('Pa').value *
                contact_pressure.to('Pa').value
            ),
            unit='Pa'
        )

    @property
    def contact_stress_is_computable(self) -> bool:
        """Whether is possible to compute the :py:attr:`contact_stress` force
        on the gear teeth. \n
        The contact stress computation depends on the value of
        :py:attr:`module`, :py:attr:`face_width` and
        :py:attr:`elastic_modulus`, so if these optional parameters have been
        set at helical gear instantiation, then it is possible to compute the
        contact stress and this property is ``True``, otherwise is ``False``.

        Returns
        -------
        :py:class:`bool`
            Whether is possible to compute the contact stress on the gear
            teeth.

        .. admonition:: See Also
           :class: seealso

           :py:meth:`compute_contact_stress`
        """
        return super().contact_stress_is_computable

    @property
    def external_torque(
            self
    ) -> Callable[[AngularPosition, AngularSpeed, Time], Torque]:
        """Custom function to compute the external torque applied on the gear.
        It must be a function with parameters ``angular_position``,
        ``angular_speed`` and ``time``. The function must return an instance of
        :py:class:`Torque <gearpy.units.units.Torque>`.

        Returns
        -------
        :py:obj:`Callable <typing.Callable>`
            The function to compute the external torque applied on the gear.

        .. admonition:: Raises
           :class: warning

           ``TypeError``
               If :py:meth:`external_torque` is not callable.
           ``KeyError``
               If :py:meth:`external_torque` misses parameters
               ``angular_position``, ``angular_speed`` or ``time``.

        .. admonition:: Examples
           :class: important

           Constant torque, not dependent on ``angular_position``,
           ``angular_speed`` or ``time``.

           >>> from gearpy.mechanical_objects import HelicalGear
           >>> from gearpy.units import InertiaMoment, Torque
           >>> gear = HelicalGear(
           ...     name='gear',
           ...     n_teeth=10,
           ...     inertia_moment=InertiaMoment(1, 'kgm^2')
           ... )
           >>> gear.external_torque = \\
           ...     lambda angular_position, angular_speed, time: Torque(5, 'Nm')

           Torque dependent on ``angular_position`` and ``time``. \n
           In this case the gear gets a periodic load, dependent on time, and
           an extra load dependent on its angular position. The dependence by
           angular position may be used to model cases where cams are involved.

           >>> import numpy as np
           >>> from gearpy.units import AngularPosition, AngularSpeed, Time
           >>> def custom_external_torque(
           ...     angular_position: AngularPosition,
           ...     angular_speed: AngularSpeed,
           ...     time: Time
           ... ) -> Torque:
           >>>     return Torque(
           ...         value=angular_position.sin() +
           ...         np.cos(time.to('sec').value),
           ...         unit='Nm'
           ...     )
           >>> gear.external_torque = custom_external_torque

           Torque dependent on ``angular_position``, ``angular_speed`` and
           ``time``. \n
           With respect ot the previous case, the gear gets an extra load
           dependent on its angular speed. The dependence by angular speed may
           be used to model cases where air friction is not negligible.

           >>> def complex_external_torque(
           ...     angular_position: AngularPosition,
           ...     angular_speed: AngularSpeed,
           ...     time: Time
           ... ) -> Torque:
           >>>     return Torque(
           ...         value=angular_position.sin() +
           ...         0.001*(angular_speed.to('rad/s').value)**2 +
           ...         np.cos(time.to('sec').value),
           ...         unit='Nm'
           ...     )
           >>> gear.external_torque = complex_external_torque
        """
        return super().external_torque

    @external_torque.setter
    def external_torque(
        self,
        external_torque: Callable[
            [AngularPosition, AngularSpeed, Time],
            Torque
        ]
    ):
        super(
            HelicalGear,
            type(self)
        ).external_torque.fset(self, external_torque)

    @property
    def time_variables(self) -> dict[str, list[UnitBase]]:
        """Time variables of the gear. Each time variable is stored as a
        dictionary key-value pair. The available time variables are:

        - :py:attr:`angular_position`: ``'angular position'``,
        - :py:attr:`angular_speed`: ``'angular speed'``,
        - :py:attr:`angular_acceleration`: ``'angular acceleration'``,
        - :py:attr:`torque`: ``'torque'``,
        - :py:attr:`driving_torque`: ``'driving torque'``,
        - :py:attr:`load_torque`: ``'load torque'``,
        - :py:attr:`tangential_force`: ``'tangential force'``,
        - :py:attr:`bending_stress`: ``'bending stress'``,
        - :py:attr:`contact_stress`: ``'contact stress'``.

        ``'tangential force'``, ``'bending stress'`` and ``'contact stress'``
        are listed among time variables only if they are computable indeed,
        depending on which gear parameters are set at gear instantiation; see
        :py:attr:`tangential_force_is_computable`,
        :py:attr:`bending_stress_is_computable` and
        :py:attr:`contact_stress_is_computable` for more details. \n
        Corresponding values of the dictionary are lists of the respective time
        variable values. \n
        At each time iteration, the :py:class:`Solver <gearpy.solver.Solver>`
        appends every time variables' values to the relative list in the
        dictionary.

        Returns
        -------
        :py:class:`dict`
            Time variables of the gear.

        .. admonition:: See Also
           :class: seealso

           :py:meth:`update_time_variables`
        """
        return super().time_variables

    def update_time_variables(self) -> None:
        """It updates :py:attr:`time_variables` dictionary by appending the
        last value of each time variable (key of the dictionary) to
        corresponding list (value of the dictionary).
        """
        super().update_time_variables()
